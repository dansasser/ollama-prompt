{
  "model": "deepseek-v3.1:671b-cloud",
  "created_at": "2025-10-26T22:07:22.929784451Z",
  "done": true,
  "done_reason": "stop",
  "total_duration": 35017544079,
  "load_duration": null,
  "prompt_eval_count": 2103,
  "prompt_eval_duration": null,
  "eval_count": 3592,
  "eval_duration": null,
  "response": "# Database Design for ollama-prompt Session Management\n\n## 1. DATABASE SCHEMA (SQLite)\n\n```sql\n-- sessions table - core session storage\nCREATE TABLE IF NOT EXISTS sessions (\n    session_id TEXT PRIMARY KEY,\n    context TEXT NOT NULL DEFAULT '',\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    last_used TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    max_context_tokens INTEGER DEFAULT 64000,\n    history_json TEXT, -- JSON array of message objects\n    metadata_json TEXT, -- JSON for additional session metadata\n    model_name TEXT, -- Track which model this session uses\n    system_prompt TEXT -- Optional system prompt for this session\n);\n\n-- session_history table (optional - for detailed audit trail)\nCREATE TABLE IF NOT EXISTS session_history (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    session_id TEXT NOT NULL,\n    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    role TEXT NOT NULL, -- 'user', 'assistant', 'system'\n    content TEXT NOT NULL,\n    tokens_used INTEGER DEFAULT 0,\n    FOREIGN KEY (session_id) REFERENCES sessions(session_id) ON DELETE CASCADE\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS idx_sessions_last_used ON sessions(last_used);\nCREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions(created_at);\nCREATE INDEX IF NOT EXISTS idx_session_history_session_id ON session_history(session_id);\nCREATE INDEX IF NOT EXISTS idx_session_history_timestamp ON session_history(timestamp);\n```\n\n## 2. STORAGE LAYER ARCHITECTURE\n\n### Module Structure: `session_manager.py`\n\n```python\n\"\"\"\nSession management and database layer for ollama-prompt\nHandles persistent session storage with SQLite backend\n\"\"\"\n\nimport os\nimport sqlite3\nimport json\nimport uuid\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nfrom typing import Optional, Dict, List, Any, Tuple\nimport threading\nfrom contextlib import contextmanager\n\nclass SessionManager:\n    \"\"\"Manages session storage and context persistence\"\"\"\n    \n    def __init__(self, db_path: Optional[str] = None):\n        self.db_path = self._get_default_db_path() if db_path is None else db_path\n        self._connection_pool = threading.local()\n        self._ensure_db_directory()\n        self._init_database()\n    \n    def _get_default_db_path(self) -> str:\n        \"\"\"Get cross-platform default database path\"\"\"\n        if os.name == 'nt':  # Windows\n            appdata = os.environ.get('APPDATA', os.path.expanduser('~'))\n            return os.path.join(appdata, 'ollama-prompt', 'sessions.db')\n        else:  # Linux/Mac\n            home = os.path.expanduser('~')\n            return os.path.join(home, '.ollama-prompt.db')\n    \n    def _ensure_db_directory(self):\n        \"\"\"Ensure database directory exists\"\"\"\n        db_dir = os.path.dirname(self.db_path)\n        if db_dir:\n            os.makedirs(db_dir, exist_ok=True)\n    \n    @contextmanager\n    def _get_connection(self):\n        \"\"\"Thread-safe connection context manager\"\"\"\n        if not hasattr(self._connection_pool, 'connection'):\n            self._connection_pool.connection = sqlite3.connect(\n                self.db_path, \n                check_same_thread=False,\n                timeout=30.0\n            )\n            self._connection_pool.connection.row_factory = sqlite3.Row\n        yield self._connection_pool.connection\n    \n    def _init_database(self):\n        \"\"\"Initialize database schema\"\"\"\n        with self._get_connection() as conn:\n            conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS sessions (\n                    session_id TEXT PRIMARY KEY,\n                    context TEXT NOT NULL DEFAULT '',\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    last_used TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    max_context_tokens INTEGER DEFAULT 64000,\n                    history_json TEXT,\n                    metadata_json TEXT,\n                    model_name TEXT,\n                    system_prompt TEXT\n                )\n            \"\"\")\n            \n            conn.execute(\"\"\"\n                CREATE INDEX IF NOT EXISTS idx_sessions_last_used \n                ON sessions(last_used)\n            \"\"\")\n            \n            # Try to create session_history table (optional)\n            try:\n                conn.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS session_history (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        session_id TEXT NOT NULL,\n                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        role TEXT NOT NULL,\n                        content TEXT NOT NULL,\n                        tokens_used INTEGER DEFAULT 0,\n                        FOREIGN KEY (session_id) REFERENCES sessions(session_id) ON DELETE CASCADE\n                    )\n                \"\"\")\n            except sqlite3.Error:\n                pass  # Table might already exist or foreign keys not supported\n            \n            conn.commit()\n\n    # CRUD Operations\n    def create_session(self, \n                      session_id: Optional[str] = None,\n                      max_context_tokens: int = 64000,\n                      model_name: Optional[str] = None,\n                      system_prompt: Optional[str] = None) -> str:\n        \"\"\"Create a new session with optional parameters\"\"\"\n        session_id = session_id or str(uuid.uuid4())\n        now = datetime.now().isoformat()\n        \n        with self._get_connection() as conn:\n            conn.execute(\"\"\"\n                INSERT INTO sessions \n                (session_id, context, created_at, last_used, max_context_tokens, \n                 history_json, metadata_json, model_name, system_prompt)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n            \"\"\", (\n                session_id, '', now, now, max_context_tokens,\n                json.dumps([]), json.dumps({}), model_name, system_prompt\n            ))\n            conn.commit()\n        \n        return session_id\n    \n    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Retrieve session data by ID\"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.execute(\"\"\"\n                SELECT * FROM sessions WHERE session_id = ?\n            \"\"\", (session_id,))\n            row = cursor.fetchone()\n            \n            if row:\n                return {\n                    'session_id': row['session_id'],\n                    'context': row['context'],\n                    'created_at': row['created_at'],\n                    'last_used': row['last_used'],\n                    'max_context_tokens': row['max_context_tokens'],\n                    'history': json.loads(row['history_json'] or '[]'),\n                    'metadata': json.loads(row['metadata_json'] or '{}'),\n                    'model_name': row['model_name'],\n                    'system_prompt': row['system_prompt']\n                }\n            return None\n    \n    def update_session_context(self, \n                             session_id: str, \n                             context: str,\n                             prompt: Optional[str] = None,\n                             response: Optional[str] = None,\n                             tokens_used: int = 0) -> bool:\n        \"\"\"Update session context and history\"\"\"\n        session = self.get_session(session_id)\n        if not session:\n            return False\n        \n        # Update history if prompt/response provided\n        history = session['history']\n        if prompt and response:\n            history.extend([\n                {'role': 'user', 'content': prompt, 'timestamp': datetime.now().isoformat()},\n                {'role': 'assistant', 'content': response, 'timestamp': datetime.now().isoformat()}\n            ])\n        \n        # Prune context if needed\n        pruned_context, pruned_history = self._prune_context_to_max_tokens(\n            context, history, session['max_context_tokens']\n        )\n        \n        now = datetime.now().isoformat()\n        \n        with self._get_connection() as conn:\n            conn.execute(\"\"\"\n                UPDATE sessions \n                SET context = ?, last_used = ?, history_json = ?\n                WHERE session_id = ?\n            \"\"\", (pruned_context, now, json.dumps(pruned_history), session_id))\n            \n            # Optional: Log to session_history table\n            if prompt and response:\n                try:\n                    conn.execute(\"\"\"\n                        INSERT INTO session_history \n                        (session_id, role, content, tokens_used)\n                        VALUES (?, 'user', ?, ?)\n                    \"\"\", (session_id, prompt, tokens_used // 2))\n                    \n                    conn.execute(\"\"\"\n                        INSERT INTO session_history \n                        (session_id, role, content, tokens_used)\n                        VALUES (?, 'assistant', ?, ?)\n                    \"\"\", (session_id, response, tokens_used // 2))\n                except sqlite3.Error:\n                    pass  # Ignore if table doesn't exist\n            \n            conn.commit()\n        \n        return True\n    \n    def delete_session(self, session_id: str) -> bool:\n        \"\"\"Delete a session and its history\"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.execute(\"DELETE FROM sessions WHERE session_id = ?\", (session_id,))\n            conn.commit()\n            return cursor.rowcount > 0\n    \n    def list_sessions(self, \n                     limit: int = 100, \n                     offset: int = 0) -> List[Dict[str, Any]]:\n        \"\"\"List all sessions with pagination\"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.execute(\"\"\"\n                SELECT session_id, created_at, last_used, max_context_tokens, model_name\n                FROM sessions \n                ORDER BY last_used DESC \n                LIMIT ? OFFSET ?\n            \"\"\", (limit, offset))\n            \n            return [\n                {\n                    'session_id': row['session_id'],\n                    'created_at': row['created_at'],\n                    'last_used': row['last_used'],\n                    'max_context_tokens': row['max_context_tokens'],\n                    'model_name': row['model_name']\n                }\n                for row in cursor.fetchall()\n            ]\n    \n    def purge_old_sessions(self, days: int = 30) -> int:\n        \"\"\"Delete sessions older than specified days\"\"\"\n        cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()\n        \n        with self._get_connection() as conn:\n            cursor = conn.execute(\"\"\"\n                DELETE FROM sessions \n                WHERE last_used < ?\n            \"\"\", (cutoff_date,))\n            conn.commit()\n            return cursor.rowcount\n\n    # Context Management\n    def _prune_context_to_max_tokens(self, \n                                   context: str, \n                                   history: List[Dict[str, Any]],\n                                   max_tokens: int) -> Tuple[str, List[Dict[str, Any]]]:\n        \"\"\"\n        Prune context and history to fit within max token limit\n        Uses simple character-based estimation (4 chars \u2248 1 token)\n        \"\"\"\n        # Simple token estimation (can be replaced with proper tokenizer)\n        def estimate_tokens(text: str) -> int:\n            return max(1, len(text) // 4)\n        \n        current_tokens = estimate_tokens(context)\n        \n        # If context alone exceeds limit, truncate it\n        if current_tokens > max_tokens:\n            # Truncate context to fit within limit\n            max_chars = max_tokens * 4\n            context = context[:max_chars]\n            return context, []  # Clear history if context is truncated\n        \n        # Check if we need to prune history\n        history_tokens = sum(estimate_tokens(msg.get('content', '')) for msg in history)\n        total_tokens = current_tokens + history_tokens\n        \n        if total_tokens <= max_tokens:\n            return context, history\n        \n        # Prune oldest history messages until we fit\n        pruned_history = history.copy()\n        while total_tokens > max_tokens and pruned_history:\n            removed_msg = pruned_history.pop(0)\n            removed_tokens = estimate_tokens(removed_msg.get('content', ''))\n            total_tokens -= removed_tokens\n        \n        return context, pruned_history\n    \n    def get_session_stats(self, session_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get statistics for a session\"\"\"\n        session = self.get_session(session_id)\n        if not session:\n            return None\n        \n        history = session['history']\n        total_messages = len(history)\n        user_messages = len([msg for msg in history if msg.get('role') == 'user'])\n        assistant_messages = len([msg for msg in history if msg.get('role') == 'assistant'])\n        \n        # Estimate token usage\n        def estimate_tokens(text: str) -> int:\n            return max(1, len(text) // 4)\n        \n        total_tokens = estimate_tokens(session['context'])\n        for msg in history:\n            total_tokens += estimate_tokens(msg.get('content', ''))\n        \n        return {\n            'session_id': session_id,\n            'total_messages': total_messages,\n            'user_messages': user_messages,\n            'assistant_messages': assistant_messages,\n            'estimated_tokens': total_tokens,\n            'max_context_tokens': session['max_context_tokens'],\n            'created_at': session['created_at'],\n            'last_used': session['last_used']\n        }\n\n# Singleton instance for easy access\n_session_manager = None\n\ndef get_session_manager(db_path: Optional[str] = None) -> SessionManager:\n    \"\"\"Get or create session manager instance\"\"\"\n    global _session_manager\n    if _session_manager is None:\n        _session_manager = SessionManager(db_path)\n    return _session_manager\n\n# Public API functions\ndef create_or_load_session(session_id: Optional[str] = None,\n                          max_context_tokens: int = 64000,\n                          model_name: Optional[str] = None,\n                          system_prompt: Optional[str] = None) -> str:\n    \"\"\"Create new session or load existing one\"\"\"\n    manager = get_session_manager()\n    \n    if session_id:\n        existing_session = manager.get_session(session_id)\n        if existing_session:\n            return session_id\n    \n    return manager.create_session(session_id, max_context_tokens, model_name, system_prompt)\n\ndef update_session_context(session_id: str, \n                          context: str,\n                          prompt: Optional[str] = None,\n                          response: Optional[str] = None,\n                          tokens_used: int = 0) -> bool:\n    \"\"\"Update session context with new interaction\"\"\"\n    manager = get_session_manager()\n    return manager.update_session_context(session_id, context, prompt, response, tokens_used)\n\ndef list_sessions(limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:\n    \"\"\"List all available sessions\"\"\"\n    manager = get_session_manager()\n    return manager.list_sessions(limit, offset)\n\ndef purge_old_sessions(days: int = 30) -> int:\n    \"\"\"Purge sessions older than specified days\"\"\"\n    manager = get_session_manager()\n    return manager.purge_old_sessions(days)\n\ndef get_session_stats(session_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Get statistics for a session\"\"\"\n    manager = get_session_manager()\n    return manager.get_session_stats(session_id)\n```\n\n## 3. CROSS-PLATFORM CONSIDERATIONS\n\n### File Locations:\n- **Windows**: `%APPDATA%\\ollama-prompt\\sessions.db`\n- **Linux/Mac**: `~/.ollama-prompt.db`\n\n### Security:\n- Database files created with user-only permissions (600)\n- No sensitive data stored in context (users responsible for content)\n- Automatic directory creation with proper permissions\n\n## 4. CONTEXT PRUNING LOGIC\n\n### Token Counting:\n- Uses character-based estimation (4 chars \u2248 1 token) as fallback\n- Can be enhanced with proper tokenizer if available\n\n### Pruning Strategy:\n1. If context exceeds limit: truncate context, clear history\n2. If context + history exceeds limit: remove oldest history messages first\n3. Preserves most recent interactions\n\n### Session Cleanup:\n- Automatic purge of sessions older than 30 days (configurable)\n- Manual cleanup via CLI commands\n\n## 5. USAGE EXAMPLE\n\n```python\n# Initialize session manager\nsession_manager = get_session_manager()\n\n# Create or load session\nsession_id = create_or_load_session(\"my-conversation\")\n\n# Update context after interaction\nupdate_session_context(\n    session_id=session_id,\n    context=new_context,\n    prompt=user_prompt,\n    response=ai_response,\n    tokens_used=token_count\n)\n\n# List sessions\nsessions = list_sessions()\nfor session in sessions:\n    print(f\"Session: {session['session_id']}, Last used: {session['last_used']}\")\n\n# Cleanup old sessions\npurged_count = purge_old_sessions(days=30)\nprint(f\"Purged {purged_count} old sessions\")\n```\n\nThis design provides a robust, cross-platform session management system that meets all the requirements while maintaining simplicity and performance.",
  "thinking": null,
  "context": null
}
